1525741336334:(symbol "foo" "moop")
1525741344733:(symbol "foo.bar" "moop")
1525741352517:(symbol "foo-foo.bar" "moop")
1525741387666:(require (symbol "foo-foo.bar" "moop") :verbose)
1525741401277:(require (symbol "foo.bar" "moop") :verbose)
1525741417628:(require (symbol "foo.bar/moop") :verbose)
1525741434441:(require (symbol "foo.bar.moop") :verbose)
1525741528050:(def ^:const input-file ["add-max-then-find.txt"])
1525741531729:input-file
1525741542034:(def ^:const input-file "add-max-then-find.txt")
1525741552530:(clojure.java.io/resource input-file)
1525741565946:(clojure.java.io/reader (clojure.java.io/resource input-file))
1525741623844:(clojure.java.io/reader input-file)
1525743036414:(def i 3)
1525743045879:(var "trie" i)
1525743053043:(var (str "trie" i))
1525743078361:(var\n (str "trie" i))
1525743085231::repl/help
1525743187435:(var (str "trie" i))
1525743194445:(str "trie" i)
1525743215795:(symbol (str "trie" i))
1525743233024:(defn trie3 [] :foo)
1525743236433:(trie3)
1525743260559:(def foofn (symbol (str "trie" i)))
1525743263973:(foofn)
1525743287132:(def foofn (var (symbol (str "trie" i))))
1525743374767:(symbol (str "trie" i))
1525743388315:(var (symbol (str "trie" i)))
1525745093279:((var (symbol (str "trie" i))))
1525745104806:((symbol (str "trie" i)))
1525745130262:(var trie3)
1525745142899:((symbol (str "user/trie" i)))
1525745153865:(var user/trie3)
1525745165490:(var (symbol (str "user/trie" i)))
1525745187701:(symbol user/trie3)
1525745194461:(symbol 'user/trie3)
1525745206154:(var (symbol (str "user/trie" i)))
1525748384596:((symbol (str "user/trie" i)))
1525748490179:((symbol (str "trie" i)))
1525748512138:(var (symbol (str "trie" i)))
1525749124125:(resolve (symbol (str "trie" i)))
1525749144357:((resolve (symbol (str "trie" i))))
1525749605507:(name(resolve (symbol (str "trie" i))))
1525749710446:(resolve (symbol (str "modulo-lotus.trie.trie" \n                                         (str/pad i {:length 2 :padding "0"})\n                                         "/run")))
1525749730018:(require '[cuerdas.core :as str])
1525751130479:(require '[taoensso.tufte :as tufte :refer (defnp p profiled profile)])
1525751144299:(tufte/add-basic-println-handler! {})
1525751151226:(defn get-x [] (Thread/sleep 500)             "x val")\n(defn get-y [] (Thread/sleep (rand-int 1000)) "y val")
1525751158588:(profile ; Profile any `p` forms called during body execution\n  {} ; Profiling options; we'll use the defaults for now\n  (dotimes [_ 5]\n    (p :get-x (get-x))\n    (p :get-y (get-y))))
1525751497401:(require '[modulo-lotus.trie.core])
1525806842582:(resolve 'sdfjhskdjfh)
1525906791466::repl/help
1525906833587:(def ^:const input-file "add-max-then-find.txt")
1525906906322:(load "modulo_lotus/trie/trie08.clj")
1525906914843:(load "/modulo_lotus/trie/trie08.clj")
1525906935873:(load "/modulo_lotus/trie/trie08")
1525906952533:(load "modulo_lotus/trie/trie08")
1525906973071:(in-ns 'modulo-lotus.trie.trie08)
1525906988818:inc-word-count
1525907013001:(def db (transient {}))
1525907020129:db
1525907041945:(def name "n")
1525907106680:(update-in! db (seq name) (fnil assoc! (transient {})) :* true)
1525907113082:(seq name)
1525907129508:(println db)
1525907179557:(def db (persistent! db))
1525907182083:db
1525907192727:(println db)
1525907219525:(def db (transient {}))
1525907227078:(def name "na")
1525907232192:(update-in! db (seq name) (fnil assoc! (transient {})) :* true)
1525907360407:(update-in {} [:foo :bar :moop] (fnil inc 0))
1525907496710:(get nil :floo)
1525907520388:(assoc nil :floop 1)
1525907582415:(empty (assoc nil :floop 1))
1525907706535:(in-ns 'modulo-lotus.trie.helpers)
1525907711846:(defn update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (let [up (fn up [m ks f args]\n                     (let [[k & ks] ks\n                           v (get m k (transient (empty m)))]\n                          (println m ks)\n                          (if ks\n                            (assoc! m k (up v ks f args))\n                            (assoc! m k (apply f v args)))))]\n             (up m ks f args))))
1525907724693:(in-ns 'modulo-lotus.trie.trie08)
1525907750854:(defn update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (let [up (fn up [m ks f args]\n                     (let [[k & [1;9A[1;9Aks] ks\n                           v (get m k (transient (empty m)))]\n                          (println m ks)\n                          (if ks\n                            (assoc! m k (up v ks f args))\n                            (assoc! m k (apply f v args)))))]\n             (up m ks f args\n                 \n                 ))sdfsdf00))
1525907777444:(update-in! db \n           (seq name) (fnil assoc! (transient {})) :* true))
1525907788556:db
1525907804805:(update-in! db (seq name) (fnil assoc! (transient {})) :* true)
1525907826916:(def db (transient {}))
1525907849960:(def name "bar")
1525907853047:(seq name)
1525907872177:(update-in! db (seq name) (fnil assoc! (transient {})) :* true)
1525907985787:(defn modulo-lotus.trie.helpers/update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (let [up (fn up [m ks f args]\n                     (let [[k & ks] ks\n                           v (get m k (transient (empty m)))]\n                          (println m [k ks] v)\n                          (if ks\n                            (assoc! m k (up v ks f args))\n                            (assoc! m k (apply f v args)))))]\n             (up m ks f args))))
1525908006692:(in-ns 'modulo-lotus.trie.helpers)
1525908017982:(defn update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (let [up (fn up [m ks f args]\n                     (let [[k & ks] ks\n                           v (get m k (transient (empty m)))]\n                          (println m [k ks] v)\n                          (if ks\n                            (assoc! m k (up v ks f args))\n                            (assoc! m k (apply f v args)))))]\n             (up m ks f args))))
1525908042247:(in-ns 'modulo-lotus.trie.trie08)
1525908053353:(update-in! db (seq name) (fnil assoc! (transient {})) :* true)
1525908103781:(defn update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (println m ks)\n        (let [up (fn up [m ks f args]\n                     (let [[k & ks] ks\n                           v (get m k (transient (empty m)))]\n                          (println m [k ks] v)\n                          (if ks\n                            (assoc! m k (up v ks f args))\n                            (assoc! m k (apply f v args)))))]\n             (up m ks f args))))
1525908132205:(ns-unmap 'modulo-lotus.trie.helpers/update-in!)
1525908146694:(ns-unmap *ns* 'modulo-lotus.trie.helpers/update-in!)
1525908154501:(ns-unalias\n *ns* 'modulo-lotus.trie.helpers/update-in!)
1525908157624:(defn update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (println m ks)\n        (let [up (fn up [m ks f args]\n                     (let [[k & ks] ks\n                           v (get m k (transient (empty m)))]\n                          (println m [k ks] v)\n                          (if ks\n                            (assoc! m k (up v ks f args))\n                            (assoc! m k (apply f v args)))))]\n             (up m ks f args))))
1525908199092:(ns-unalias *ns* 'update-in!)
1525908207936:(ns-unalias *ns* \n            update-in!)
1525908218287:(ns-unmap *ns* 'update-in!)
1525908227019:(defn update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (println m ks)\n        (let [up (fn up [m ks f args]\n                     (let [[k & ks] ks\n                           v (get m k (transient (empty m)))]\n                          (println m [k ks] v)\n                          (if ks\n                            (assoc! m k (up v ks f args))\n                            (assoc! m k (apply f v args)))))]\n             (up m ks f args))))
1525908235696:(update-in! db (seq name) (fnil assoc! (transient {})) :* true)
1525908280439:(empty db)
1525908284484:db
1525908307701:(defn update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (println m ks)\n        (let [up (fn up [m ks f args]\n                     (let [[k & ks] ks\n                           v (get m k (transient {}))]\n                          (println m [k ks] v)\n                          (if ks\n                            (assoc! m k (up v ks f args))\n                            (assoc! m k (apply f v args)))))]\n             (up m ks f args))))
1525908315298:(update-in! db (seq name) (fnil assoc! (transient {})) :* true)
1525908718337:(defn update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (println m ks)\n        (let [up (fn up [m ks f args]\n                     (let [[k & ks] ks]\n                          (println m [k ks] v)\n                          (if ks\n                            (assoc! m k (up (get m k (transient {})) ks f args))\n                            (assoc! m k (apply f (get m k) args)))))]\n             (up m ks f args))))
1525908735724:(defn update-in!\n      "'Updates' a value in a nested associative structure, where ks is a\n      sequence of keys and f is a function that will take the old value\n      and any supplied args and return the new value, and returns a new\n      nested structure.  If any levels do not exist, hash-maps will be\n      created."\n      {:added "1.0"\n       :static true}\n      ([m ks f & args]\n        (let [up (fn up [m ks f args]\n                     (let [[k & ks] ks]\n                          (println m [k ks])\n                          (if ks\n                            (assoc! m k (up (get m k (transient {})) ks f args))\n                            (assoc! m k (apply f (get m k) args)))))]\n             (up m ks f args))))
1525908742548:(update-in! db (seq name) (fnil assoc! (transient {})) :* true)
1525908760961:(inc-word-count db name)
1525908873254:(update-in! db (seq name) (fnil assoc! (transient {})) :* true)
1525908875086:(inc-word-count db name)
1525908892042:(def db (update-in! db (seq name) (fnil assoc! (transient {})) :* true))
1525908895729:db
1525908909935:(inc-word-count db name)
1525908925376:(def db (persistent! db))
1525908926617:db
1525908973729:(def db (transient db))
1525908975488:db
1525978461871:(def db (transient db))
